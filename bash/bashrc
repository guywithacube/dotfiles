#!/usr/bin/env bash
# vim: set filetype=sh :

DOTFILES_DIR=$HOME/.dotfiles
BASH_DIR=$DOTFILES_DIR/bash

# If not running interactively, don't do anything
# https://unix.stackexchange.com/a/257613
case $- in
	*i*)
		;;
	*)
		return
		;;
esac

# Check window size after each command.
# Update LINES and COLUMNS if needed.
shopt -s checkwinsize

# Recursive double-wildcard (**)
shopt -s globstar

# Better less for non-text input files
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

if [ -f "$HOME/.bash_aliases" ]; then
	# shellcheck source=/dev/null
	source "$HOME/.bash_aliases"
fi

# Root user warning
# Check effective user ID
if [ "$(id -u)" = "0" ]; then
	echo "BE CAREFUL, YOU ARE ROOT"
fi

# Disable <C-s>
bind -r "C-s"
stty -ixon

# If Vim is installed, set as default editor
# https://unix.stackexchange.com/a/73486
# Attempt to fetch path to Vim
path_to_vim=$(command -v vim)
# Verify path_to_vim leads to an executable
if [ -x "$path_to_vim" ]; then
	export VISUAL=$path_to_vim
	export EDITOR=$path_to_vim
fi

# Configure color
SUPPORTS_COLORS=false
# Check if tput is available
if [ -x "$(command -v tput)" ]; then
	tput_colors=$(tput colors 2> /dev/null)
	return_value=$?
	if [ $return_value -eq 0 ] && [ "$tput_colors" -gt 0 ]; then
		SUPPORTS_COLORS=true
	fi
else
	# TODO: Refactor! This is an unreliable/bad way to check for color support.
	case "$TERM" in
		xterm-color | *-256color)
			SUPPORTS_COLORS=true
			;;
	esac
fi
if $SUPPORTS_COLORS; then
	# For *BSD/Darwin
	export CLICOLOR=1
fi

# Load files
for script in "$BASH_DIR"/bashrc.d/*.sh; do
	# shellcheck source=/dev/null
	source "$script"
done

# Private / machine specific
for file in "$BASH_DIR"/private.d/*.sh; do
	# shellcheck source=/dev/null
	[ -r "$file" ] && [ -f "$file" ] && source "$file"
done
